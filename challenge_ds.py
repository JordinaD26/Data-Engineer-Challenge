# -*- coding: utf-8 -*-
"""Challenge_DS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16sAciWDQA_W7A7MbiCYwDK6Cm-0l9uaA
"""

import numpy as np

def distance(i,j,cell, rotations):
  r=len(cell)
  c=len(cell[0])
  if rotations%2==0:
    dist1=abs(r-i-3)+abs(c-1-j)
    dist2=abs(r-i-2)+abs(c-j-2)
  else:
    dist1=abs(r-i-2)+abs(c-2-j)
    dist2=abs(r-1-i)+abs(c-j-3)
  if dist1<dist2:
    x=i+1
    y=j
  else:
    x=i
    y=j+1
  return x,y

def nearest(i,j,cell, rotations):
  near=np.array([])
  if (cell[i+1][j]>cell[i][j+1]):
    near=np.r_[near,[i,j+1]]
  elif (cell[i+1][j]<cell[i][j+1]):
    near=np.r_[near,[i+1,j]]
  elif (cell[i+1][j]==cell[i][j+1]) and (cell[i+1][j]<len(cell)*len(cell[0]-1)):
    x,y=distance(i,j, cell, rotations)
    near=np.r_[near,[x,y]]
  else:
    near=np.r_[near,[i,j]]
  return near

def fowardHorizontal(i,j,cell):
  r=len(cell)
  c=len(cell[0])
  if (cell[i][j+1]<c*r-1) and (cell[i][j+2]<c*r-1) and (cell[i][j+3]<c*r-1):
    possible_movement=True
  else:
    possible_movement=False

  return possible_movement

def fowardVertical(i,j,cell):
  r=len(cell)
  c=len(cell[0])
  if (cell[i][j+1]<c*r-1) and (cell[i+1][j+1]<c*r-1) and (cell[i+2][j+1]<c*r-1):
    possible_movement=True
  else:
    possible_movement=False
  return possible_movement

def downwardsHorizontal(i,j,cell):
  r=len(cell)
  c=len(cell[0])
  if (cell[i+1][j]<c*r-1) and (cell[i+1][j+1]<c*r-1) and (cell[i+1][j+2]<c*r-1):
    possible_movement=True
  else:
    possible_movement=False
  return possible_movement

def downwardsVertical(i,j,cell):
  r=len(cell)
  c=len(cell[0])
  if (cell[i+1][j]<c*r-1) and (cell[i+2][j]<c*r-1) and (cell[i+3][j]<c*r-1):
    possible_movement=True
  else:
    possible_movement=False
  return possible_movement

def CheckFoward(rotations,i,j,cell):
  if rotations%2==0:
    fow=fowardHorizontal(i,j,cell)
  else:
    fow=fowardVertical(i,j,cell)
  return fow

def CheckDownwards(rotations,i,j,cell):
  if rotations%2==0:
    down=downwardsHorizontal(i,j,cell)
  else:
    down=downwardsVertical(i,j,cell)
  return down

def PossibleRotation(rotations,i,j,cell):
  r=len(cell)
  c=len(cell[0])
  if (rotations%2==0 and (cell[i][j]!=c*r) and (cell[i-1][j]!=c*r) and (cell[i-1][j+1]!=c*r) and (cell[i-1][j+1]!=c*r)
  and (cell[i][j+1]!=c*r) and (cell[i][j+2]!=c*r) and (cell[i+1][j]!=c*r) and (cell[i+1][j+1]!=c*r) and (cell[i][j+2]!=c*r)):
    rotat=True
  elif (rotations%2!=0 and (cell[i][j]!=c*r) and (cell[i][j-1]!=c*r) and (cell[i+1][j-1]!=c*r) and (cell[i+2][j-1]!=c*r)
  and (cell[i+1][j]!=c*r) and (cell[i+2][j]!=c*r) and (cell[i][j+1]!=c*r) and (cell[i+1][j+1]!=c*r) and (cell[i+2][j+1]!=c*r)):
    rotat=True
  else:
    rotat=False
  return rotat

labyrinth=[['.','.','.','.','.','.','.','.','.','.'],
           ['.','#','.','.','.','.','#','.','.','.'],
           ['.','#','.','.','.','.','.','.','.','.'],
           ['.','.','.','.','.','.','.','.','.','.'],
           ['.','.','.','.','.','.','.','.','.','.'],
           ['.','#','.','.','.','.','.','.','.','.'],
           ['.','#','.','.','.','#','.','.','.','.'],
           ['.','.','.','.','.','.','#','.','.','.'],
           ['.','.','.','.','.','.','.','.','.','.'],
           ['.','.','.','.','.','.','.','.','.','.']]
rows=len(labyrinth)
columns=len(labyrinth[0])
cell=np.empty(shape=(rows,columns))

i=0
while i < rows:
  j=0
  while j < columns:
    if labyrinth[i][j]=='.':
       cell[i][j]=i+j
    else:
      cell[i][j]=rows*columns
    j+=1
  i+=1

before_cell=np.array([])
rotations=0
goal=False
i=0
j=0
k=0
next_cells=np.array([])
near=np.array([])
next_cells=np.r_[next_cells,[0,0]]

while goal==False and k<10000:
  #comprovem que no arribem meta
  if (rotations%2==0 and i==rows-1 and j==columns-3) or (rotations%2!=0 and i==rows-3 and j==columns-1):
    goal=True
  #mirem que no estiguem als extrems cella
  elif (i>=(rows-1) and rotations%2==0) or (i>=(rows-3) and rotations%2!=0):
    fow=CheckFoward(rotations,i,j,cell)
    if fow==True:
      next_cells=np.r_[next_cells,[i,j+1]]
      j+=1
    else:
      rot=PossibleRotation(rotations,i,j,cell)
      if rot==True:
        if rotations%2==0:
          i-=1
          j+=1
        else:
          i+=1
          j-=1
        rotations+=1
        next_cells= np.r_[next_cells,[i,j]]
      else:
        cell[int(next_cells[len(next_cells)-2])][int(next_cells[len(next_cells)-1])]=rows*columns-1
        next_cells=np.delete(next_cells,len(next_cells)-1)
        next_cells=np.delete(next_cells,len(next_cells)-1)
        i=int(next_cells[len(next_cells)-2])
        j=int(next_cells[len(next_cells)-1])
  elif (j>=(columns-3) and rotations%2==0) or (j>=(columns-1) and rotations%2!=0):
    down=CheckDownwards(rotations,i,j,cell)
    if down==True:
      next_cells=np.r_[next_cells,[i+1,j]]
      i+=1
    else:
      rot=PossibleRotation(rotations,i,j,cell)
      if rot==True:
        if rotations%2==0:
          i-=1
          j+=1
        else:
          i+=1
          j-=1
        rotations+=1
        next_cells= np.r_[next_cells,[i,j]]
      else:
        cell[int(next_cells[len(next_cells)-2])][int(next_cells[len(next_cells)-1])]=rows*columns-1
        next_cells=np.delete(next_cells,len(next_cells)-1)
        next_cells=np.delete(next_cells,len(next_cells)-1)
        i=int(next_cells[len(next_cells)-2])
        j=int(next_cells[len(next_cells)-1])

  #si ni estem als limits ni a meta busquem seguent cella
  else:
    near=nearest(i,j, cell, rotations)
    next_cells= np.r_[next_cells,[near[0],near[1]]]

    #proxima cela esta endavant
    if (next_cells[len(next_cells)-2]==i) and (next_cells[len(next_cells)-1]==j+1):
      fow=CheckFoward(rotations,i,j,cell)
      if fow==True:
        i=int(next_cells[len(next_cells)-2])
        j=int(next_cells[len(next_cells)-1])
      else:
        cell[int(next_cells[len(next_cells)-2])][int(next_cells[len(next_cells)-1])]=rows*columns-1
        next_cells=np.delete(next_cells,len(next_cells)-1)
        next_cells=np.delete(next_cells,len(next_cells)-1)
        i=int(next_cells[len(next_cells)-2])
        j=int(next_cells[len(next_cells)-1])

    #proxima cela esta avall
    elif (next_cells[len(next_cells)-2]==i+1) and (next_cells[len(next_cells)-1]==j):
      down=CheckDownwards(rotations,i,j,cell)
      if down==True:
        i=int(next_cells[len(next_cells)-2])
        j=int(next_cells[len(next_cells)-1])
      else:
        cell[int(next_cells[len(next_cells)-2])][int(next_cells[len(next_cells)-1])]=rows*columns-1
        next_cells=np.delete(next_cells,len(next_cells)-1)
        next_cells=np.delete(next_cells,len(next_cells)-1)
        i=int(next_cells[len(next_cells)-2])
        j=int(next_cells[len(next_cells)-1])

    #no hi ha proxima cella
    else:
      rot=PossibleRotation(rotations,i,j,cell)
      if rot==True:
        if rotations%2==0:
          i-=i
          j+=1
        else:
          i+=i
          j-=j
        rotations+=1
        next_cells= np.r_[next_cells,[i,j]]
      else:
        cell[int(next_cells[len(next_cells)-2])][int(next_cells[len(next_cells)-1])]=rows*columns-1
        next_cells=np.delete(next_cells,len(next_cells)-1)
        next_cells=np.delete(next_cells,len(next_cells)-1)
        i=int(next_cells[len(next_cells)-2])
        j=int(next_cells[len(next_cells)-1])

  if rotations%2==0 and (j<columns-3 or i< rows-1):
    if (cell[i+1][j]>=rows*columns-1) and (cell[i][j+1]>=rows*columns-1):
      if i==0 and j==0:
        k=10000
      else:
        next_cells=np.delete(next_cells,len(next_cells)-1)
        next_cells=np.delete(next_cells,len(next_cells)-1)
  if rotations%2!=0 and (j<columns-1 or i< rows-3):
    if (cell[i+1][j]>=rows*columns-1) and (cell[i][j+1]>=rows*columns-1):
      if i==0 and j==0:
        k=10000
      else:
        next_cells=np.delete(next_cells,len(next_cells)-1)
        next_cells=np.delete(next_cells,len(next_cells)-1)

  k+=1

if k<10000:
  print(int((len(next_cells)-1)/2))
else:
  print(-1)

